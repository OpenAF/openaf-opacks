include:
- oJobHTTPd.yaml
- oJobBrowse.yaml

#ojob:
#  daemon: true
#  logToConsole: true

jobs:
# ------------------------
- name : HTTP Browse - codeartifact
  to   : HTTP Browse generic
  typeArgs:
    noLog   : false
    shortcut:
      name  : CodeArtifactBrowse
      keyArg: port
      args  :
        accessKey : accessKey
        secret    : secret
        token     : token
        region    : region
        assumeRole: assumeRole
        uri       : uri
        path      : path
        browse    : browse
        logo      : logo
        incURI    : incURI
        cache     : cache
        sortTab   : sortTab
        options   : options
        domain    : domain
        repository: repository
        format    : format
        namespace : namespace
        initialize: initialize
  exec : | #js
    args.options = merge(args.options, {
      showURI : args.incURI,
      sortTab : args.sortTab,
      logo    : args.logo,
      browse  : args.browse,
      default : args.default
    })

    loadLib("aws.js")
    var aws = new AWS(args.accessKey, args.secret, args.token)
    if (isDef(args.assumeRole)) {
      log("Assuming role " + args.assumeRole + "...")
      aws = aws.assumeRole(args.assumeRole)
    }

    var getAWS = () => {
      var _aws = new AWS(args.accessKey, args.secret, args.token)
      if (isDef(args.assumeRole)) {
        log("Assuming role " + args.assumeRole + "...")
        _aws = _aws.assumeRole(args.assumeRole)
      }
      return _aws
    }

    var buildPackageTree = aPackages => {
      var _packages = pForEach(aPackages || [], p => {
        var parts = [ p.format ]
        if (isDef(p.namespace) && p.namespace.length > 0) parts.push(p.namespace)
        parts.push(p.package)
        return merge({ path: parts.join("/") }, p)
      })

      var _parents = []
      var _parentsMap = {}
      var _childrenMap = {}
      var _leafByPath = {}

      for(var i = 0; i < _packages.length; i++) {
        var r = _packages[i]
        var parts = r.path.split("/")
        for(var j = 0; j < parts.length; j++) {
          var parent = parts.slice(0, j + 1).join("/")
          var key = parent + "|" + (j + 1)
          if (!isDef(_parentsMap[key])) {
            var entry = { name: parent, isParent: parent != r.path, level: j + 1, pkg: r }
            _parentsMap[key] = entry
            _parents.push(entry)
          } else if (parent == r.path) {
            _parentsMap[key].isParent = false
            _parentsMap[key].pkg = r
          }

          if (j > 0) {
            var prefix = parts.slice(0, j).join("/")
            if (!isDef(_childrenMap[prefix])) _childrenMap[prefix] = []
            if (_childrenMap[prefix].indexOf(parent) == -1) _childrenMap[prefix].push(parent)
          }
        }
        _leafByPath[r.path] = r
      }

      Object.keys(_childrenMap).forEach(k => _childrenMap[k].sort())

      return { list: _packages, parents: _parents, parentsMap: _parentsMap, childrenMap: _childrenMap, leafByPath: _leafByPath }
    }

    var getPaging = (page, pageSize) => {
      var _pageSize = isDef(pageSize) ? Number(pageSize) : Number(isDef(args.pageSize) ? args.pageSize : (args.options || {}).pageSize)
      if (isNaN(_pageSize) || _pageSize <= 0) _pageSize = 0
      var _page = isDef(page) ? Number(page) : Number(isDef(args.page) ? args.page : (args.options || {}).page)
      if (isNaN(_page) || _page <= 0) _page = 1
      return { pageSize: _pageSize, page: _page }
    }

    var applyPaging = (aList, page, pageSize) => {
      var p = getPaging(page, pageSize)
      var _list = isArray(aList) ? aList : []
      var total = _list.length

      if (p.pageSize <= 0) {
        return {
          list       : _list,
          total      : total,
          page       : 1,
          pageSize   : 0,
          totalPages : 1,
          hasPrevious: false,
          hasNext    : false
        }
      }

      var totalPages = Math.max(1, Math.ceil(total / p.pageSize))
      var currentPage = Math.min(Math.max(1, p.page), totalPages)
      var start = (currentPage - 1) * p.pageSize

      return {
        list       : _list.slice(start, start + p.pageSize),
        total      : total,
        page       : currentPage,
        pageSize   : p.pageSize,
        totalPages : totalPages,
        hasPrevious: currentPage > 1,
        hasNext    : currentPage < totalPages
      }
    }

    var withPagingInfo = (lst, pageInfo) => merge({
      pageInfo: {
        total      : pageInfo.total,
        page       : pageInfo.page,
        pageSize   : pageInfo.pageSize,
        totalPages : pageInfo.totalPages,
        hasPrevious: pageInfo.hasPrevious,
        hasNext    : pageInfo.hasNext
      }
    }, lst)

    // Paging options: pageSize/page can be passed as args or via args.options
    args.fns = {
      init   : () => {
        $cache("codeartifact-domains")
        .ttl(args.cache)
        .fn(() => {
          var _aws = getAWS()
          var lst = _aws.CODEARTIFACT_ListDomains(args.region)
          if (isDef(args.domain)) lst = lst.filter(f => (f.domainName || f.name) == args.domain)
          return lst
        })
        .create()

        $cache("codeartifact-repos")
        .ttl(args.cache)
        .fn(k => {
          var _aws = getAWS()
          var lst = _aws.CODEARTIFACT_ListRepositories(args.region, args.repository)
          if (isDef(k.domain)) lst = lst.filter(f => f.domainName == k.domain)
          return lst
        })
        .create()

        $cache("codeartifact-packages")
        .ttl(args.cache)
        .fn(k => {
          var _aws = getAWS()
          log(`Fetching packages for domain ${k.domain} and repository ${k.repository}...`)
          var lst = _aws.CODEARTIFACT_ListPackages(args.region, k.repository, k.domain, args.format)
          if (isDef(args.namespace)) lst = lst.filter(f => f.namespace == args.namespace)
          log(`Fetched ${lst.length} packages for domain ${k.domain} and repository ${k.repository}.`)
          return lst
        })
        .create()

        $cache("codeartifact-package-tree")
        .ttl(args.cache)
        .fn(k => {
          log(`Building package tree for domain ${k.domain} and repository ${k.repository}...`)
          var packages = $cache("codeartifact-packages").get(k)
          log(`Built package tree for domain ${k.domain} and repository ${k.repository}.`)
          return buildPackageTree(packages)
        })
        .create()

        $cache("codeartifact-versions")
        .ttl(args.cache)
        .fn(k => {
          var _aws = getAWS()
          return _aws.CODEARTIFACT_ListPackageVersions(args.region, k.repository, k.domain, k.format, k.namespace, k.package)
        })
        .create()

        $cache("codeartifact-assets")
        .ttl(args.cache)
        .fn(k => {
          var _aws = getAWS()
          return _aws.CODEARTIFACT_ListPackageVersionAssets(args.region, k.repository, k.domain, k.format, k.namespace, k.package, k.version)
        })
        .create()

        if (isDef(args.initialize)) {
          $doV(() => {
            var _inits = af.fromJSSLON(args.initialize)
            pForEach(_inits, i => {
              $cache("codeartifact-package-tree").get({
                domain    : i.domain,
                repository: i.repository
              })
            })
          })
        }
      },
      getList: (request, options) => {
        const uri = request.uri
        var puri = uri.replace(new RegExp("^" + options.parentURI + "/?"), "").replace(/\/+$/, "")
        var parts = puri.split("/").filter(r => r.length > 0)
        var reqParams = isMap(request.params) ? request.params : {}
        var reqPage = isDef(reqParams.page) ? Number(reqParams.page) : __
        var reqPageSize = __

        if (parts.length == 0) {
          var domains = $cache("codeartifact-domains").get({})
          var paged = applyPaging($from(domains).sort("domainName").select(d => {
            return {
              isDirectory: true,
              values     : {
                "Domain" : d.domainName || d.name,
                "Owner"  : d.owner || "",
                "Created": isDef(d.createdTime) ? new Date(d.createdTime).toISOString().replace(/T/, " ").replace(/\..+/, "") : ""
              }
            }
          }), reqPage, reqPageSize)
          return withPagingInfo({
            isList: true,
            fields: [ "Domain", "Owner", "Created" ],
            alignFields: [ "left", "left", "left" ],
            key   : [ "Domain" ],
            list  : paged.list
          }, paged)
        }

        if (parts.length == 1) {
          var domain = parts[0]
          var repos = $cache("codeartifact-repos").get({ domain: domain })
          var paged = applyPaging($from(repos).sort("repositoryName").select(r => {
            return {
              isDirectory: true,
              values     : {
                "Repository" : r.repositoryName || r.name,
                "Domain"     : r.domainName || "",
                "Owner"      : r.owner || "",
                "Description": r.description || ""
              }
            }
          }), reqPage, reqPageSize)
          return withPagingInfo({
            isList: true,
            fields: [ "Repository", "Domain", "Owner", "Description" ],
            alignFields: [ "left", "left", "left", "left" ],
            key   : [ "Repository" ],
            list  : paged.list
          }, paged)
        }

        var domain = parts[0]
        var repo = parts[1]
        var remaining = parts.slice(2).join("/")

        var packages = $cache("codeartifact-packages").get({ domain: domain, repository: repo })
        var tree = $cache("codeartifact-package-tree").get({ domain: domain, repository: repo })
        var lstParent = tree.parents
        var childrenMap = tree.childrenMap || {}
        var leafByPath = tree.leafByPath || {}

        if (remaining.length == 0) {
          var rootChildren = childrenMap[""] || $from(lstParent).equals("level", 1).select(r => r.name).sort()
          var paged = applyPaging($from(rootChildren).select(name => {
            var f = tree.parentsMap[name + "|1"]
            return {
              isDirectory: f.isParent,
              values     : {
                "Package"  : f.name,
                "Format"   : f.pkg.format || "",
                "Namespace": f.pkg.namespace || ""
              }
            }
          }), reqPage, reqPageSize)
          return withPagingInfo({
            isList: true,
            fields: [ "Package", "Format", "Namespace" ],
            alignFields: [ "left", "left", "left" ],
            key   : [ "Package" ],
            list  : paged.list
          }, paged)
        }

        var level = remaining.split("/").filter(r => r.length > 0).length

        if (remaining.length > 0) {
          var remParts = remaining.split("/").filter(r => r.length > 0)
          if (remParts.length > 1) {
            var ver = remParts[remParts.length - 1]
            var pkgPath = remParts.slice(0, -1).join("/")
            var leafPkg = leafByPath[pkgPath]
            if (isDef(leafPkg)) {
              var versions = $cache("codeartifact-versions").get({
                domain    : domain,
                repository: repo,
                format    : leafPkg.format,
                namespace : leafPkg.namespace,
                package   : leafPkg.package
              })

              if ($from(versions).equals("version", ver).any()) {
                return { isFile: true }
              }
            }
          }

          if (!isDef(childrenMap[remaining]) && !isDef(leafByPath[remaining])) {
            return { isFile: false }
          }
        }

        var leaf = leafByPath[remaining]
        if (isDef(leaf)) {
          var versions = $cache("codeartifact-versions").get({
            domain    : domain,
            repository: repo,
            format    : leaf.format,
            namespace : leaf.namespace,
            package   : leaf.package
          })

          var _paged = applyPaging($from(versions).sort("-publishedTime").select(v => {
            return {
              isDirectory: false,
              values     : {
                "Version"  : v.version || "",
                "Status"   : v.status || "",
                "Published": isDef(v.publishedTime) ? new Date(v.publishedTime).toISOString().replace(/T/, " ").replace(/\..+/, "") : ""
              }
            }
          }), reqPage, reqPageSize)
          return withPagingInfo({
            isList: true,
            fields: [ "Version", "Status", "Published" ],
            alignFields: [ "left", "left", "left" ],
            key   : [ "Version" ],
            list  : _paged.list
          }, _paged)
        }

        var listPrefix = remaining
        var listNames = childrenMap[listPrefix] || []
        var paged = applyPaging($from(listNames).select(name => {
          var f = tree.parentsMap[name + "|" + (level + 1)]
          return {
            isDirectory: f.isParent,
            values     : {
              "Package"  : f.name.replace(new RegExp("^" + remaining + "/?"), "") + (f.isParent ? "/" : ""),
              "Format"   : f.pkg.format || "",
              "Namespace": f.pkg.namespace || ""
            }
          }
        }), reqPage, reqPageSize)
        return withPagingInfo({
          isList: true,
          fields: [ "Package", "Format", "Namespace" ],
          alignFields: [ "left", "left", "left" ],
          key   : [ "Package" ],
          list  : paged.list
        }, paged)
      },
      getObj: (request, options) => {
        const uri = request.uri
        var puri = uri.replace(new RegExp("^" + options.parentURI + "/?"), "").replace(/\/+$/, "")
        var parts = puri.split("/").filter(r => r.length > 0)

        var domain = parts[0]
        var repo = parts[1]
        var version = parts[parts.length - 1]
        var pkgParts = parts.slice(2, -1)
        var format = pkgParts[0]
        var pkg = pkgParts[pkgParts.length - 1]
        var namespace = pkgParts.length > 2 ? pkgParts.slice(1, -1).join("/") : __

        var assets = $cache("codeartifact-assets").get({
          domain    : domain,
          repository: repo,
          format    : format,
          namespace : namespace,
          package   : pkg,
          version   : version
        })
        traverse(assets, (aK, aV, aP, aO) => {
          if (aK == "SHA-512") {
            delete aO[aK]
          }
        })

        var data = "\n"
        data += `## ðŸ“¦ Package version assets\n\n`
        data += `ðŸ·ï¸ **Domain:** \`${domain}\`  \n`
        data += `ðŸ“¦ **Repository:** \`${repo}\`  \n`
        data += `ðŸ“„ **Package:** \`${pkg}\`  \n`
        data += `ðŸ§© **Format:** \`${format}\`  \n`
        data += `ðŸ§­ **Namespace:** ${isDef(namespace) ? "`" + namespace + "`" : ""}  \n`
        data += `ðŸ”– **Version:** \`${version}\`\n\n---\n`

        data += "| Asset | Size | Hashes |\n"
        data += "|:---|---:|---|\n"
        $from(assets).sort("assetName").select(a => {
          data += `| ${a.name || a.assetName || ""} | ${isDef(a.size) ? ow.format.toBytesAbbreviation(a.size) : ""} | ${af.toYAML(a.hashes).replace(/\n/g, "</br>") || ""} |\n`
        })

        if (options.sortTab) data += "<script src=\"/js/mdtablesort.js\"></script>\n"

        return {
          data: data,
          type: "raw"
        }
      }
    }


# todo:
# - (httpdStart): 33221
#   ((mapLibs )): true
# - (CodeArtifactBrowse): 33221
#   ((region          )): eu-west-1
#   ((uri             )): /test
#   ((browse          )): true
#   ((cache           )): 3600000
#   ((options         )):
#     pageSize: 250
